#!/usr/bin/env python
#   Parallel uploads to Amazon AWS S3
#   Copyright (C) 2011  Tom Payne
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO
from gzip import GzipFile
import hashlib
import logging
from multiprocessing import JoinableQueue, Process, current_process
from optparse import OptionGroup, OptionParser
import os.path
import re
from ssl import SSLError
import sys
import tarfile
import time

from boto.s3.connection import S3Connection


DONE_RE = re.compile(r'\AINFO:s3-parallel-put\[putter-\d+\]:\S+\s+->\s+(\S+)\s*\Z')


class Value(object):

    def __init__(self, content=None, filename=None, md5=None, offset=None, path=None, size=None):
        self.content = content
        self.filename = filename
        self.md5 = md5
        self.offset = offset
        self.path = path
        self.size = size

    def get_content(self):
        if self.content is None:
            if self.filename:
                with open(self.filename) as fp:
                    fp.seek(self.offset)
                    self.content = fp.read(self.size)
            elif self.path:
                with open(self.path) as fp:
                    self.content = fp.read(self.size)
            else:
                assert False
        return self.content

    def get_md5(self):
        if self.md5 is None:
            self.md5 = hashlib.md5(self.get_content()).hexdigest()
        return self.md5

    def get_size(self):
        if self.size is None:
            if self.content:
                self.size = len(self.content)
            elif self.path:
                self.size = os.stat(self.path).st_size
            else:
                assert False
        return self.size


class LimitReached(Exception):
    pass


class Walker(object):

    def __init__(self, put_queue, sources, options):
        self.put_queue = put_queue
        self.sources = sources
        self.options = options
        self.logger = logging.getLogger('%s[walker-%d]' % (os.path.basename(sys.argv[0]), current_process().pid))
        self.logger.debug('starting')
        done = set()
        for filename in options.resume:
            with open(filename) as fp:
                for line in fp:
                    m = DONE_RE.match(line)
                    if m:
                        done.add(m.group(1))
        limit = self.options.limit
        try:
            for source in sources:
                for key_name, args in self.walk(source):
                    if key_name in done:
                        continue
                    if limit == 0:
                        raise LimitReached
                    limit -= 1
                    put_queue.put((key_name, args))
        except LimitReached:
            pass
        self.logger.debug('terminating')

    def walk(self, source):
        raise NotImplementedError


class TarWalker(Walker):

    def walk(self, source):
        try:
            tf = tarfile.open(source, 'r:')
            for tarinfo in tf:
                if tarinfo.isfile():
                    path = tarinfo.name
                    key_name = os.path.normpath(os.path.join(self.options.prefix, path))
                    filename = source
                    offset = tarinfo.offset_data
                    size = tarinfo.size
                    yield (key_name, dict(filename=filename, offset=offset, path=path, size=size))
        except tarfile.ReadError:
            tf = tarfile.open(source)
            for tarinfo in tf:
                if tarinfo.isfile():
                    path = tarinfo.name
                    key_name = os.path.normpath(os.path.join(self.options.prefix, path))
                    content = tf.extractfile(tarinfo).read()
                    yield (key_name, dict(content=content, path=path))


class TreeWalker(Walker):

    def walk(self, source):
        if os.path.isdir(source):
            for dirpath, dirnames, filenames in os.walk(source):
                for filename in filenames:
                    path = os.path.join(dirpath, filename)
                    if not os.path.isfile(path):
                        continue
                    key_name = os.path.normpath(os.path.join(self.options.prefix, path))
                    yield (key_name, dict(path=path))
        elif os.path.isfile(source):
            key_name = os.path.normpath(os.path.join(self.options.prefix, source))
            yield (key_name, dict(path=path))


def add_heuristic(self, key_name, value):
    key = self.bucket.get_key(key_name)
    if key is None:
        return self.bucket.new_key(key_name)
    else:
        return None


def stupid_heuristic(bucket, key_name, value):
    return bucket.new_key(key_name)


def update_heuristic(bucket, key_name, value):
    key = bucket.get_key(key_name)
    if key is None:
        return bucket.new_key(key_name)
    else:
        if key.etag == '"%s"' % value.get_md5():
            return None
        else:
            return key

def putter(heuristic, put_queue, stat_queue, options):
    logger = logging.getLogger('%s[putter-%d]' % (os.path.basename(sys.argv[0]), current_process().pid))
    logger.debug('starting')
    connection, bucket = None, None
    while True:
        args = put_queue.get()
        if args is None:
            put_queue.task_done()
            break
        key_name, value_kwargs = args
        value = Value(**value_kwargs)
        try:
            if connection is None:
                connection = S3Connection(is_secure=options.secure)
            if bucket is None:
                bucket = connection.get_bucket(options.bucket)
            key = heuristic(bucket, key_name, value)
            if key:
                headers = {}
                if options.content_type:
                    headers['Content-Type'] = options.content_type
                content = value.get_content()
                if options.gzip:
                    headers['Content-Encoding'] = 'gzip'
                    string_io = StringIO()
                    gzip_file = GzipFile(compresslevel=9, fileobj=string_io, mode='w')
                    gzip_file.write(content)
                    gzip_file.close()
                    content = string_io.getvalue()
                if not options.dry_run:
                    key.set_contents_from_string(content, headers, md5=value.md5)
                logger.info('%s -> %s' % (value.path, key.name))
                stat_queue.put(dict(size=value.get_size()))
            else:
                logger.info('skipping %s -> %s' % (value.path, key_name))
        except SSLError as e:
            logger.error('%s -> %s (%s)' % (value.path, key_name, e))
            connection, bucket = None, None
        put_queue.task_done()
    logger.debug('terminating')


def statter(stat_queue, start, options):
    logger = logging.getLogger('%s[statter-%d]' % (os.path.basename(sys.argv[0]), current_process().pid))
    logger.debug('starting')
    count, total_size = 0, 0
    while True:
        kwargs = stat_queue.get()
        if kwargs is None:
            stat_queue.task_done()
            break
        count += 1
        total_size += kwargs.get('size', 0)
        stat_queue.task_done()
    duration = time.time() - start
    logger.info('put %d bytes in %d files in %.1f seconds (%d bytes/s, %.1f files/s)' % (total_size, count, duration, total_size / duration, count / duration))
    logger.debug('terminating')


def main(argv):
    parser = OptionParser()
    group = OptionGroup(parser, 'S3 options')
    group.add_option('--bucket', metavar='BUCKET',
            help='set bucket')
    group.add_option('--insecure', action='store_false', dest='secure',
            help='use insecure connection')
    group.add_option('--secure', action='store_true', default=True, dest='secure',
            help='use secure connection')
    parser.add_option_group(group)
    group = OptionGroup(parser, 'Source options')
    group.add_option('--tar', action='store_true',
            help='treat sources as tar files')
    parser.add_option_group(group)
    group = OptionGroup(parser, 'Put options')
    group.add_option('--content-type', metavar='CONTENT-TYPE',
            help='set content type')
    group.add_option('--gzip', action='store_true',
            help='gzip values and set content encoding')
    group.add_option('--mode', choices=('add', 'stupid', 'update'), default='update', metavar='MODE',
            help='set mode (add, stupid, or update)')
    group.add_option('--prefix', default='', metavar='PREFIX',
            help='set key prefix')
    group.add_option('--resume', action='append', default=[], metavar='FILENAME',
            help='resume from log file')
    parser.add_option_group(group)
    group = OptionGroup(parser, 'Logging options')
    group.add_option('--log-filename', metavar='FILENAME',
            help='set log filename')
    group.add_option('--quiet', '-q', action='count', default=0,
            help='less output')
    group.add_option('--verbose', '-v', action='count', default=0,
            help='more output')
    parser.add_option_group(group)
    group = OptionGroup(parser, 'Debug and performance tuning options')
    group.add_option('--dry-run', action='store_true',
            help='don\'t write to S3')
    group.add_option('--limit', default=-1, metavar='N', type=int,
            help='set maximum number of keys to put')
    group.add_option('--processes', default=8, metavar='PROCESSES', type=int,
            help='set number of putter processes')
    parser.add_option_group(group)
    options, args = parser.parse_args(argv[1:])
    logging.basicConfig(filename=options.log_filename, level=logging.INFO + 10 * (options.quiet - options.verbose))
    logger = logging.getLogger(os.path.basename(sys.argv[0]))
    if len(args) < 1:
        logger.error('missing source operand')
        return 1
    if not options.bucket:
        logger.error('missing bucket')
        return 1
    connection = S3Connection(is_secure=options.secure)
    bucket = connection.get_bucket(options.bucket)
    del bucket
    del connection
    start = time.time()
    put_queue = JoinableQueue(1024 * options.processes)
    stat_queue = JoinableQueue()
    walker = TarWalker if options.tar else TreeWalker
    walker_process = Process(target=walker, args=(put_queue, args, options))
    walker_process.start()
    logger.debug('started walker-%d' % walker_process.pid)
    heuristics = dict(add=add_heuristic, stupid=stupid_heuristic, update=update_heuristic)
    putter_processes = [Process(target=putter, args=(heuristics[options.mode], put_queue, stat_queue, options)) for i in xrange(options.processes)]
    for putter_process in putter_processes:
        putter_process.start()
        logger.debug('started putter-%d' % putter_process.pid)
    statter_process = Process(target=statter, args=(stat_queue, start, options))
    statter_process.start()
    logger.debug('started statter-%d' % statter_process.pid)
    logger.debug('joining walker-%d' % walker_process.pid)
    walker_process.join()
    logger.debug('shutting down put_queue')
    for putter_process in putter_processes:
        put_queue.put(None)
    put_queue.close()
    for putter_process in putter_processes:
        logger.debug('joining putter-%d' % putter_process.pid)
        putter_process.join()
    logger.debug('shutting down stat_queue')
    stat_queue.put(None)
    stat_queue.close()
    logger.debug('joining statter-%d' % walker_process.pid)
    statter_process.join()
    logger.debug('joining put_queue')
    put_queue.join_thread()
    logger.debug('joining stat_queue')
    stat_queue.join_thread()


if __name__ == '__main__':
    sys.exit(main(sys.argv))
